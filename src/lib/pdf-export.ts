import jsPDF from "jspdf";
import autoTable, { RowInput } from "jspdf-autotable";
import type { InternshipData, DailyLog } from "@/types/internship";
import { formatDateLong } from "./utils/date";

// PDF export options interface
export interface ExportOptions {
  internship: InternshipData;
  startDate?: Date;
  endDate?: Date;
  includeNotes?: boolean;
  format?: "summary" | "detailed";
}

// Sanitize user input to prevent potential issues in PDF
function sanitizeText(text: string): string {
  return text
    .replace(/[^\w\s\-_.,()\[\]]/g, "") // Remove special characters except basic ones
    .trim()
    .substring(0, 1000); // Limit length to prevent performance issues
}

// Format hours display
function formatHours(hours: number): string {
  return hours === 1 ? "1 hour" : `${hours} hours`;
}

// Calculate date range for logs
function getDateRange(
  logs: Record<string, DailyLog>,
  startDate?: Date,
  endDate?: Date
) {
  const logDates = Object.keys(logs)
    .map((dateKey) => new Date(dateKey))
    .filter((date) => !isNaN(date.getTime()))
    .sort((a, b) => a.getTime() - b.getTime());

  if (logDates.length === 0) return { start: null, end: null };

  const start = startDate || logDates[0];
  const end = endDate || logDates[logDates.length - 1];

  return { start, end };
}

// Generate filtered logs based on date range
function getFilteredLogs(
  dailyLogs: Record<string, DailyLog>,
  startDate?: Date,
  endDate?: Date
): Array<{ date: Date; log: DailyLog; dateKey: string }> {
  const filteredLogs: Array<{ date: Date; log: DailyLog; dateKey: string }> =
    [];

  for (const [dateKey, log] of Object.entries(dailyLogs)) {
    const date = new Date(dateKey);

    // Skip invalid dates
    if (isNaN(date.getTime())) continue;

    // Apply date range filter
    if (startDate && date < startDate) continue;
    if (endDate && date > endDate) continue;

    filteredLogs.push({ date, log, dateKey });
  }

  return filteredLogs.sort((a, b) => a.date.getTime() - b.date.getTime());
}

// Generate PDF document
export async function exportWorkLogsToPDF(
  options: ExportOptions
): Promise<Blob> {
  const {
    internship,
    startDate,
    endDate,
    includeNotes = true,
    format = "detailed",
  } = options;

  // Input validation and sanitization
  const companyName = sanitizeText(internship.company);
  const position = sanitizeText(internship.position);

  const filteredLogs = getFilteredLogs(
    internship.dailyLogs,
    startDate,
    endDate
  );
  const { start: actualStartDate, end: actualEndDate } = getDateRange(
    internship.dailyLogs,
    startDate,
    endDate
  );

  // Performance optimization: bail out if no data
  if (filteredLogs.length === 0) {
    throw new Error("No work logs found for the selected date range");
  }

  // Calculate summary statistics
  const totalHours = filteredLogs.reduce((sum, { log }) => sum + log.hours, 0);
  const totalDays = filteredLogs.length;
  const averageHours = totalDays > 0 ? totalHours / totalDays : 0;

  // Initialize PDF document
  const pdf = new jsPDF();
  let currentY = 20;

  // Header
  pdf.setFontSize(20);
  pdf.setFont("helvetica", "bold");
  pdf.text("Work Log Export", 20, currentY);
  currentY += 8;

  // App credit
  pdf.setFontSize(10);
  pdf.setFont("helvetica", "italic");
  pdf.setTextColor(128);
  pdf.text("Generated by InternTrack", 20, currentY);
  pdf.setTextColor(0); // Reset to black
  currentY += 12;

  // Company and position info
  pdf.setFontSize(14);
  pdf.setFont("helvetica", "normal");
  pdf.text(`Company: ${companyName}`, 20, currentY);
  currentY += 8;
  pdf.text(`Position: ${position}`, 20, currentY);
  currentY += 8;

  // Date range
  if (actualStartDate && actualEndDate) {
    pdf.text(
      `Period: ${formatDateLong(actualStartDate)} - ${formatDateLong(
        actualEndDate
      )}`,
      20,
      currentY
    );
    currentY += 8;
  }

  // Export metadata
  pdf.setFontSize(10);
  pdf.setTextColor(128);
  pdf.text(`Generated on: ${formatDateLong(new Date())}`, 20, currentY);
  pdf.text(`Total entries: ${totalDays}`, 120, currentY);
  currentY += 15;
  pdf.setTextColor(0); // Reset to black

  // Summary section
  pdf.setFontSize(16);
  pdf.setFont("helvetica", "bold");
  pdf.text("Summary", 20, currentY);
  currentY += 10;

  pdf.setFontSize(12);
  pdf.setFont("helvetica", "normal");
  pdf.text(`Total Hours Worked: ${formatHours(totalHours)}`, 20, currentY);
  currentY += 6;
  pdf.text(`Working Days: ${totalDays}`, 20, currentY);
  currentY += 6;
  pdf.text(
    `Average Hours per Day: ${averageHours.toFixed(1)} hours`,
    20,
    currentY
  );
  currentY += 6;
  pdf.text(
    `Progress: ${totalHours}/${internship.totalHours} hours (${(
      (totalHours / internship.totalHours) *
      100
    ).toFixed(1)}%)`,
    20,
    currentY
  );
  currentY += 15;

  // Detailed logs section
  if (format === "detailed") {
    pdf.setFontSize(16);
    pdf.setFont("helvetica", "bold");
    pdf.text("Detailed Work Logs", 20, currentY);
    currentY += 10;

    // Prepare table data
    const headers = includeNotes
      ? ["Date", "Hours", "Notes"]
      : ["Date", "Hours"];

    const tableData: RowInput[] = filteredLogs.map(({ date, log }) => {
      const row = [formatDateLong(date), formatHours(log.hours)];

      if (includeNotes) {
        row.push(sanitizeText(log.notes || "No notes"));
      }

      return row;
    });

    // Generate table with performance considerations
    autoTable(pdf, {
      head: [headers],
      body: tableData,
      startY: currentY,
      styles: {
        fontSize: 10,
        cellPadding: 4,
        overflow: "linebreak",
        cellWidth: "wrap",
      },
      columnStyles: {
        0: { cellWidth: 40 }, // Date column
        1: { cellWidth: 20 }, // Hours column
        ...(includeNotes && { 2: { cellWidth: "auto" } }), // Notes column
      },
      headStyles: {
        fillColor: [66, 139, 202], // Professional blue
        textColor: [255, 255, 255],
        fontStyle: "bold",
      },
      alternateRowStyles: {
        fillColor: [245, 245, 245],
      },
      tableLineColor: [200, 200, 200],
      tableLineWidth: 0.5,
      theme: "grid",
      // Performance optimization: limit table height
      showFoot: "lastPage",
      pageBreak: "auto",
    });
  }

  // Footer with page numbers
  const pageCount = (
    pdf as { internal: { getNumberOfPages(): number } }
  ).internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setTextColor(128);
    pdf.text(
      `Page ${i} of ${pageCount}`,
      pdf.internal.pageSize.getWidth() - 40,
      pdf.internal.pageSize.getHeight() - 10
    );
  }

  // Convert to blob for download
  const pdfBlob = pdf.output("blob");

  return pdfBlob;
}

// Generate filename for export
export function generateExportFilename(
  internship: InternshipData,
  startDate?: Date,
  endDate?: Date
): string {
  const companyName = internship.company.replace(/[^a-zA-Z0-9]/g, "_");
  const position = internship.position.replace(/[^a-zA-Z0-9]/g, "_");
  const dateStr = new Date().toISOString().split("T")[0];

  let filename = `WorkLog_${companyName}_${position}_${dateStr}`;

  if (startDate && endDate) {
    const start = startDate.toISOString().split("T")[0];
    const end = endDate.toISOString().split("T")[0];
    filename += `_${start}_to_${end}`;
  }

  return `${filename}.pdf`;
}

// Trigger download of PDF blob
export function downloadPDFBlob(blob: Blob, filename: string): void {
  // Create download link
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;

  // Trigger download
  document.body.appendChild(link);
  link.click();

  // Cleanup
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Main export function that combines everything
export async function exportWorkLogs(options: ExportOptions): Promise<void> {
  try {
    // Generate PDF
    const pdfBlob = await exportWorkLogsToPDF(options);

    // Generate filename
    const filename = generateExportFilename(
      options.internship,
      options.startDate,
      options.endDate
    );

    // Download
    downloadPDFBlob(pdfBlob, filename);
  } catch (error) {
    console.error("PDF export failed:", error);
    throw new Error(
      error instanceof Error ? error.message : "Failed to export PDF"
    );
  }
}
